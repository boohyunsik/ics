# 1: Inter-blockchain Communication Protocol Architecture

**IBC 프로토콜의 고수준의 아키텍처 및 데이터 흐름에 대한 개요입니다.**

**IBC 사양에 사용되는 용어에 대한 정의는 [여기를](./1_IBC_TERMINOLOGY.md) 참조하십시오.**

**일반적인 프로토콜 설계 원칙에 대해서는 [여기를](./3_IBC_DESIGN_PRINCIPLES.md) 참조하십시오.**

**사용 사례는 [여기를](./4_IBC_USECASES.md) 참조하십시오.**

**디자인 패턴에 대한 설명은 [여기를](./5_IBC_DESIGN_PATTERNS.md) 참조하십시오.**

이 문서는 블록체인간 통신 (IBC) 스택에서 사용되는 인증 계층, 통신 계층, 오더링(ordering) 계층에 대해서 간략하게 설명합니다. 이 문서는 프로토콜의 세부 사항에 대해서는 설명하지 않습니다. -- 세부 사항들은 개별 ICS 문서에 포함되어 있습니다.

> 참고 : 이 문서 전체에서 *원장* , *체인* 및 *블록 체인* 은 일반적으로 사용되는 의미를 따릅니다.

## IBC란 무엇인가

*블록체인간 통신 프로토콜*(IBC)은 신뢰할 수 있고 안전한 모듈간 통신 프로토콜이며, 여기서 모듈은 결정적인 프로세스들을 말하며 각 프로세스는 복제된 독립적인 머신들 위에서 동작합니다. 그리고 이 독립적인 머신들은 복제된 상태를 가지는 머신을 포함하는 것을 말합니다. (좀 더 구체적으로 복제된 상태를 가지는 머신은 "블록체인"이나 "분산된 원장"을 말합니다.)

IBC는 안정적이고 안전한 모듈 간 통신을 기반으로 구축 된 모든 응용 프로그램에서 사용할 수 있습니다. 애플리케이션 예로는 교차 체인 자산 전송(cross-chain asset transfer), 아토믹 스왑(atomic swap), 다중 체인 스마트 계약 (서로 호환되지 않는 VM을 가지는 체인을 포함해서) 그리고 다양한 종류의 데이터 및 코드 샤딩이 있습니다.

## IBC에서 제공하지 않는것들

IBC는 응용 프로그램 계층 프로토콜이 아니며 데이터 전송, 인증 및 안정성만 처리합니다.

IBC는 아토믹 스왑(atomic-swap) 프로토콜이 아닙니다. 임의의 서로 다른 체인을 넘나드는 데이터 전송 및 연산이 지원됩니다.

IBC는 토큰 전송 프로토콜이 아닙니다. 토큰 전송은 IBC 프로토콜을 응용 프로그램 계층에서 사용할 수 있습니다.

IBC는 샤딩 프로토콜이 아닙니다. 단일 스테이트 머신이 체인간에 분산되어 사용되는 것이 아니라 다양한 종류의 다른 스테이트 머신들이 공용 인터페이스를 가지고 있으며 각각이 다른 체인위에서 동작합니다.

IBC는 Layer-2 스케일링 프로토콜이 아닙니다. IBC를 구현하는 모든 체인은 동일한 "계층"에 존재하지만 각 체인은 네트워크 토폴로지 다른 부분에 있을 수 있습니다. 하지만 그 중에 꼭 루트 체인이 있거나 한 개의 검증자가 있는 것은 아닙니다.

## 동기

현재 비트코인과 이더리움과 같은 주요 블록체인에 대해서 쓰기 작업을 할 때 초당 7~20개의 트랜잭션의 속도를 지원합니다. 두 체인 모두 여전히 얼리어답터 애호가들이 주로 사용하고 있지만 최근까지 비교적 안정적으로 운영되고 있습니다. 낮은 처리량이 대부분의 블록체인 사용 사례에서 한계점으로 꼽히고 있습니다. 그리고 낮은 처리량은 분산 스테이트 머신의 근본적인 한계로 알려져있습니다.
네트워크에 존재하는 모든 (검증하는) 노드들은 모든 트랜잭션(모듈식 영지식 구성은 현재 문서에서 논외로 합니다.)을 처리해야하기 때문에 모든 상태를 저장하고 다른 검증 노드들과 통신합니다. [Tendermint](https://github.com/tendermint/tendermint) 와 같은 빠른 합의 알고리즘은 처리량을 큰 상수의 요소로 증가시킬 수는 있지만 이 이유로 무한정 늘릴 수는 없습니다. 트랜잭션 처리량과 응용 프로그램 다양성 그리고 효율적인 비용을 통한 분산 원장 어플리케이션 배포를 지원하려면 동시에 실행할 수있는 여러 독립적인 합의 인스턴스간에 실행 및 저장소를 분리해야합니다.

한 가지 설계 방향은 "샤드"라고 하는 하나의 프로그래밍이 가능한 스테이트 머신을 다른 체인들로 나누는 것입니다. 그리고 각 샤드는 동시에 실행될 수 있고 상태의 서로 다른 부분을 저장할 수 있습니다. 안전성과 생동성을 고려하고 샤드간에 데이터와 코드를 올바르게 라우팅하려면 이러한 설계는 "하향식 접근 방식"을 취해야합니다 -- 이것은 네트워크 토폴로지를 구성하는 것, 하나의 루트를 가지는 원장과 트리 형태의 샤드를 만드는 것, 프로토콜 규약을 만드는 것과 토폴로지들에게 인센티브를 주는 것을 포함합니다. 이러한 접근 방식은 간단하고 예측 가능하다는 것에 장점이 있지만 어려운 [기술적 문제를](https://medium.com/nearprotocol/unsolved-problems-in-blockchain-sharding-2327d6517f43) 직면하고 있습니다. 이러한 문제에서는 모든 샤드들이 각자 하나의 검증자의 집합을 가져야 하며 하나의 스테이트 머신 혹은 상호 호환 가능한 VM을 가져야 합니다. 그리고 가까운 미래에 네트워크 토폴로지를 변경하기 위한 합의를 확장하기 어렵다는 문제를 가질 수 있습니다.

또한 단일 합의 알고리즘, 스테이트 머신, 시빌 저항성(sybil resistence)에서 충분한 수준의 보안 및 다양성을 제공하지 못할 수도 있습니다. 합의에 참여하는 인스턴스의 숫자는 그들이 지원할 수 있는 독립적인 인스턴스 수에 제한되어 있습니다. 이것은 합의에 참여하는 인스턴스의 숫자가 늘어남에 따라 특정 오퍼레이터를 손상시켰을 때 발생하는 이익이 커지는 것을 뜻합니다 -- 오퍼레이터를 손상시키기 위한 비용은 항상 최적의 비용을 따라가려고 할 것입니다. (예 : 물리적 키 유출 또는 사회 공학) 그러므로 이 비용은 무한정 증가하지 않습니다. 하나의 글로벌 스테이트 머신은 다양한 어플리케이션들 중 공통의 것들을 수용해야합니다. 이를 통해 특별한 스테이트 머신 보다 특정 형태의 어플리케이션을 덜 적합하도록 만들 수 있습니다. 하나의 합의 인스턴스의 운영자들은 그들의 권력을 남용하여 쉽게 리더 선출에서 빠져나갈 수 없는 어플리케이션으로부터 수수료를 가져갈 수 있습니다. 그렇기 때문에 별도의 독립적인 합의 인스턴스들이 최소한의 필요한 공통 인터페이스만을 가져가면서 상호작용하는 구조를 만들어나가는 것이 더 적합합니다.

*인터 블록 체인 통신 프로토콜* 은 스케일링과 상호 운용성 문제에 대해서 다른 접근방식을 취하고 있습니다. 이종 분산 원장 네트워크의 안전하고 신뢰할 수있는 상호 운용을 가능하게하며 알려지지 않은 토폴로지로 정렬하고 가능한 경우 비밀을 유지하며 원장을 다양화할 수 있습니다. 그리고 네트워크에서 원장들은 다양화될 수 있고, 발전할 수 있으며 독립적으로 관리될 수 있습니다. 또한 특정 조건의 토폴로지나 특정 형태의 스테이트 머신 디자인을 따라서도 다르게 구성될 수 있습니다.
더 넓고 동적인 여러 네트워크에 걸쳐있는 체인들은 이따금 일어나는 Byzantine faults가 일어날 수 있으며 따라서 이러한 경우에 대비해 프로토콜 레벨에서 이를 발견하고 극복할 수 있어야합니다. 더 자세한 설계 원칙 목록은 [여기를](./3_IBC_DESIGN_PRINCIPLES.md) 참조하십시오.

다양한 형태의 블록체인이 서로 소통을 편하게 하기 위해서는 블록체인간 커뮤니케이션 프로토콜은 "상향식" 접근 방법을 취하고 있습니다. 이 프로토콜에서는 상호 운용을 구현하는데 필요한 요구 사항, 기능, 그리고 다른 두 원장이 소통하는데 필요한 특징들을 명시해야하며 고수준의 프로토콜의 요구사항을 만족하며 여러 원장들이 소통하기 위한 다양한 방법들을 명시해야합니다. 따라서 IBC는 전체 네트워크 토폴로지에 대해 아무 것도 가정하지 않으며 구현 원장에 대해서는 알려진 최소한의 기능만 사용할 수 있고 몇 가지의 특징만 충족하면 됩니다. 실제로 IBC내의 원장들은 그들의 light client 합의 검증 기능들로 정의되어있기때문에 단일머신과 복잡한 알고리즘을 통해 "원장"의 기능들을 확장시키는 것으로 볼 수 있습니다.

IBC는 엔드 투 엔드(end-to-end)로 이어져있고, 연결 지향적이고 상태를 가지며 떨어진 머신들끼리 모듈을 통해 인증된 통신을 가능하게 해줍니다. IBC 구현체는 호스트의 스테이트 머신에서 고수준의 모듈들과 프로토콜의 스펙을 만족해야합니다. IBC를 호스팅하는 스테이트 머신은 합의 사본을 검증할 수 있는 기능과 암호학적인 작업 증명을 생성할 수 있는 기능을 제공해야합니다. 그리고 IBC 패킷 릴레이어는 (오프 체인 프로세스) 네트워크 프로토콜들에 접근할 수 있어야하며 스테이트 머신의 상태를 읽고 다른 머신에게 데이터를 전송하기 위해서 물리적인 데이터 링크에 접근할 수 있어야합니다.

## 범위

IBC는 별도의 시스템에 존재하는 모듈간의 중계를 위해 사용되는 구조화된 데이터 패킷의 인증, 전송 및 오더링을 처리합니다. 이 프로토콜은 두 시스템의 모듈 사이에 정의되어 있지만, 임의의 토폴로지들로 연결된 여러 시스템의 여러 모듈 사이에서도 안전한 동시 사용을 위해 설계되었습니다.

## 인터페이스

IBC는 스마트 컨트랙트, 다른 상태 머신 컴포넌트 혹은 상태 머신의 독립적인 애플리케이션 로직과 같은 모듈들과 기본 합의 프로토콜, 시스템 및 네트워크 인프라 (예 : TCP/IP) 사이에 있습니다.

IBC는 동일한 상태 머신에 존재하는 다른 모듈과 상호 작용하기 위해서 다음과 같은 기능들을 모듈에 제공합니다: 커넥션 & 채널이 맺어진 상태에서 데이터 패킷 전송 및 수신 (인증 및 오더링을 위한 기본 요소, [definition](./1_IBC_TERMINOLOGY.md) 부분 참조) - 뿐만 아니라 프로토콜 상태를 관리하기 위한 call들을 제공합니다: 1) 커넥션과 채널들을 열고 닫기, 2) 커넥션, 채널, 패킷 전송 옵션 선택하기, 3) 커넥션 & 채널의 상태 조회하기

IBC는  [ICS 2](../../spec/ics-002-client-semantics)에 정의된 완결성 (또는 임계값을 이용한 완결성), 저렴하게 검증 가능한 합의 결과 및 간단한 키/벨류 저장 기능과 같은 기본 합의 프로토콜 및 시스템의 기능 및 속성들을 가정하고 있습니다. 네트워크 측면에서 IBC는 최종 데이터 전달만을 요구합니다. 인증, 동기화 또는 오더링과 같은 속성들은 나중에 정확하게 정의되기 때문에 가정하지 않습니다.

### 프로토콜 관계도

```
+------------------------------+                           +------------------------------+
| Distributed Ledger A         |                           | Distributed Ledger B         |
|                              |                           |                              |
| +--------------------------+ |                           | +--------------------------+ |
| | State Machine            | |                           | | State Machine            | |
| |                          | |                           | |                          | |
| | +----------+     +-----+ | |        +---------+        | | +-----+     +----------+ | |
| | | Module A | <-> | IBC | | | <----> | Relayer | <----> | | | IBC | <-> | Module B | | |
| | +----------+     +-----+ | |        +---------+        | | +-----+     +----------+ | |
| +--------------------------+ |                           | +--------------------------+ |
+------------------------------+                           +------------------------------+
```

## 기능

IBC의 주요 목적은 독립된 호스트 시스템에서 실행되는 모듈간의 신뢰할 수 있고, 인증되어 있으며, 순서대로 통신할 수 있도록 도와주는 것입니다. 이를 위해서는 다음 영역들에서 프로토콜 로직이 필요합니다.

- 데이터 중계
- 데이터 기밀성 및 가독성
- 신뢰성
- 흐름 제어
- 인증
- 상태 유지
- 다중화
- 직렬화

다음 단락에서는 각 영역에 대한 IBC 내의 프로토콜 논리에 대해서 간략하게 설명합니다.

### 데이터 중계

IBC 아키텍처에서 모듈은 네트워킹 인프라를 통해 서로에게 메시지를 직접 전송하는 것이 아니라 "릴레이어 프로세스"를 모니터링하여 물리적으로 중계할 메시지를 생성합니다. IBC는 기본 네트워크 프로토콜 스택 (예 : TCP/IP, UDP/IP 또는 QUIC/IP) 및 물리적 상호 연결 인프라에 접근할 수 있는 일련의 릴레이어 프로세스가 있다고 가정합니다. 이러한 릴레이어 프로세스는 IBC 프로토콜을 구현하는 시스템들을 모니터링하여 각 시스템의 상태를 지속적으로 스캔하고 송신 패킷이 커밋된 경우 다른 시스템 상에서 트랜잭션을 실행합니다. 두 시스템 간의 커넥션에서 올바른 작동 및 진행을 위해 IBC에서는 시스템간에 중계할 수 있는 하나 이상의 올바른 라이브 릴레이어 프로세스만 있으면됩니다.

### 데이터 기밀성 및 가독성

IBC 프로토콜은 IBC 프로토콜의 올바른 작동에 필요한 최소한의 데이터 만 사용 가능하고 읽기 가능하도록하고 (표준 형식으로 직렬화됩니다.) 스테이트 머신은 특정한 릴레이어들에게만 데이터를 전달할 수 있도록 릴레이어를 선출하는 과정이 있을 수 있습니다. (릴레이어를 선출하는 자세한 과정은 이 문서의 범위를 벗어납니다.) 이 데이터는 합의 상태, 클라이언트, 커넥션, 채널 및 패킷 정보와 특정 키 / 값 쌍의 포함 또는 제외 증명을 구성하는 데 필요한 상태로 구성됩니다. 또한 다른 머신에서도 증명해야하는 모든 데이터를 읽을 수 있어야합니다. 즉,이 표준에 정의 된 형식으로 직렬화해야합니다.

### 신뢰성

네트워크 레이어와 릴레이어 프로세스들은 임의의 방식대로 동작할 수 있습니다. 예를들어 패킷을 유실, 재정렬 혹은 복제하거나 혹은 의도적으로 유효하지 않은 트랜잭션을 보내는 등 비잔틴 노드처럼 행동할 수 있습니다. 이러한 악의적인 행동은 IBC의 동작에 영향을 끼쳐서는 안됩니다. 이러한 행동을 막기 위해서 각 패킷에 시퀀스 번호를 지정하고 IBC 커넥션을 통해 전송합니다. 그리고 이것은 패킷을 수신하는 쪽 머신의 IBC 핸들러가 검증하고 (IBC 프로토콜을 구현하는 스테이트 머신의 일부입니다.) 메세지를 전송하는 머신이 다음 패킷을 전송하거나 혹은 다른 액션을 취하기 전에 패킷을 수신한 쪽의 머신이 패킷을 제대로 받고 핸들링했다는 것을 알려줄 수 있는 방법을 제공해야합니다. 암호화된 커밋들은 데이터의 위변조를 방지하기 위해 사용됩니다: 송신하는 머신은 발신 패킷에 커밋을 하고 수신하는 머신은 이 커밋을 확인합니다. 그래서 통신과정에서 변조된 데이터는 릴레이어에의해서 거부됩니다. IBC는 또한 순차적으로 데이터를 전송하지 않는 채널도 지원하는데,이 채널은 송신에 대한 패킷 수신 순서를 강제하지 않지만 정확히 한 번만 전달되도록합니다.

### 흐름 제어

IBC는 컴퓨팅 레벨과 경제학적인 흐름에 대한 컨트롤과 관련된 조항에 대해서 명시하지 않습니다. 기본즉어로 머신들은 처리량과 흐름 제어 메커니즘에 대해 한계를 가지고 있습니다. ("gas" 시장과 같은 것이 있습니다.) 어플리케이션 레벨의 경제학적인 흐름은 보안 속성을 보장하고(하나의 머신의 값을 제한합니다.) Byzantine faults에 대해 극복할 수 있게 해줍니다. (챌린지 기간을 제공하며 그 다음 커넥션을 끊습니다.) 예를 들어, IBC 채널을 통해 값을 전송하는 응용 프로그램은 잠재적 인 비잔틴 행동으로 인한 피해를 제한하기 위해 블록 당 값 전송 속도를 제한 할 수 있습니다. IBC는 모듈이 패킷을 거부하고 세부 사항을 상위 레벨 애플리케이션 프로토콜로 남겨 둘 수있는 기능을 제공합니다.

### 인증

IBC의 모든 데이터는 인증됩니다. 송신 머신의 합의 알고리즘에 의해 완성 된 블록은 암호화 커밋을 통해 발신 패킷에 포함시켜야하며 수신 체인의 IBC 핸들러는 액션을 취하기 전에 합의에 대한 사본과 암호화 커밋 증거를 모두 검증해야합니다.

### 상태 유지

위에서 설명한 안정성, 흐름 제어 및 인증을 위해서는 IBC가 각 데이터 스트림에 대한 특정 상태 정보를 초기화하고 유지해야합니다. 이 정보는 커넥션과 채널이라는 두 가지 추상화로 나뉩니다. 각 커넥션 개체에는 연결된 컴퓨터의 합의 상태에 대한 정보가 포함됩니다. 한 쌍의 모듈에 특정한 각 채널에는 협상 된 인코딩 및 멀티플렉싱 옵션과 상태 및 시퀀스 번호에 관한 정보가 포함됩니다. 두 모듈이 통신을 원할 경우 두 시스템간에 기존 커넥션 및 채널을 찾거나 존재하지 않는 경우 새 커넥션 및 채널을 초기화해야합니다. 커넥션 및 채널을 초기화하려면 다단계 핸드 셰이크가 필요합니다.이 단계를 완료하면 연결시 두 대의 머신 만 연결되고 두 개의 모듈이 연결되고 릴레이 된 향후 데이터 그램이 인증, 인코딩 및 인코딩됩니다. 채널의 경우 원하는대로 시퀀싱됩니다.

### 다중화

단일 호스트 시스템 내의 많은 모듈이 IBC 커넥션을 동시에 사용할 수 있도록 IBC는 각 커넥션 내에서 일련의 채널을 제공합니다. 각 채널은 순서가 지정된 패킷의 경우 순서대로 패킷을 보낼 수있는 데이터 스트림을 고유하게 식별합니다. 수신 시스템의 대상 모듈에 항상 정확히 한 번만 표시됩니다. 채널은 일반적으로 각 시스템의 단일 모듈과 연결될 것으로 예상되지만 일대다 및 다대일 채널도 가능합니다. 채널 수는 제한이 없으며 합의 정보를 추적하는 데 필요한 단일 커넥션만있는 기본 시스템의 처리량에 의해서만 동시 처리량이 제한됩니다.

### 직렬화

IBC는 상호 이해하기 어려운 기계 간의 인터페이스 경계 역할을하며, 프로토콜을 올바르게 구현하는 두 기계가 서로를 이해할 수 있도록 최소한의 데이터 구조 인코딩 및 데이터 그램 형식의 필수 상호 이해를 제공해야합니다. 이를 위해 IBC 사양은 데이터 구조의 표준 인코딩을 정의하며,이 리포지토리에서 프로토 타입 형식으로 제공되는 IBC를 통해 통신하는 두 시스템 간의 증거로 직렬화 및 릴레이 또는 확인되어야합니다.

> 표준 인코딩 (동일한 구조의 데이터는 항상 같은 바이트로 직렬화 되어야 합니다.)을 제공하는 proto3을 사용해야합니다. 따라서 맵 형식과 알 수없는 필드는 금지되어 있습니다.

## 데이터 흐름

IBC는 계층화 된 프로토콜 스택으로 개념화 될 수 있으며,이를 통해 데이터가 위에서 아래로 (IBC 패킷을 보낼 때) 그리고 아래에서 위로 (IBC 패킷을받을 때) 흐릅니다.

"핸들러"는 IBC 프로토콜을 구현하는 상태 머신의 일부이며, 모듈에서 패킷으로 또는 패킷으로의 호출을 변환하고 채널 및 커넥션으로 적절히 라우팅하는 역할을 담당합니다.

두 체인 사이의 IBC 패킷 경로를 고려하십시오 *-A* 와 *B* 라고 부릅니다.

### 다이어그램

```
+---------------------------------------------------------------------------------------------+
| Distributed Ledger A                                                                        |
|                                                                                             |
| +----------+     +----------------------------------------------------------+               |
| |          |     | IBC Module                                               |               |
| | Module A | --> |                                                          | --> Consensus |
| |          |     | Handler --> Packet --> Channel --> Connection --> Client |               |
| +----------+     +----------------------------------------------------------+               |
+---------------------------------------------------------------------------------------------+

    +---------+
==> | Relayer | ==>
    +---------+

+--------------------------------------------------------------------------------------------+
| Distributed Ledger B                                                                       |
|                                                                                            |
|               +---------------------------------------------------------+     +----------+ |
|               | IBC Module                                              |     |          | |
| Consensus --> |                                                         | --> | Module B | |
|               | Client -> Connection --> Channel --> Packet --> Handler |     |          | |
|               +---------------------------------------------------------+     +----------+ |
+--------------------------------------------------------------------------------------------+
```

### 과정

1. 체인 *A* 
    1.  모듈 (응용 프로그램 별) 
    2.  핸들러 (다른 ICS에 정의 된 파트) 
    3.  패킷 ( [ICS 4에](../spec/ics-004-channel-and-packet-semantics) 정의 됨) 
    4.  채널 ( [ICS 4에](../spec/ics-004-channel-and-packet-semantics) 정의 됨) 
    5.  커넥션 ( [ICS 3에](../spec/ics-003-connection-semantics) 정의 됨) 
    6.  클라이언트 ( [ICS 2에](../spec/ics-002-client-semantics) 정의 됨) 
    7.  합의 (발신 패킷과의 거래를 확인) 
2. 오프 체인 
    1.  중계기 ( [ICS 18에](../spec/ics-018-relayer-algorithms) 정의 됨) 
3. 체인 *B* 
    1.  합의 (수신 패킷과의 거래를 확인) 
    2.  클라이언트 ( [ICS 2에](/../spec/ics-002-client-semantics) 정의 됨) 
    3.  커넥션 ( [ICS 3에](/../spec/ics-003-connection-semantics) 정의 됨) 
    4.  채널 ( [ICS 4에](/../spec/ics-004-channel-and-packet-semantics) 정의 됨) 
    5.  패킷 ( [ICS 4에](/../spec/ics-004-channel-and-packet-semantics) 정의 됨) 
    6.  핸들러 (다른 ICS에 정의 된 파트) 
    7.  모듈 (응용 프로그램 별) 
